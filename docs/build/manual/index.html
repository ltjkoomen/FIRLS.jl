<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Manual · FIRLS.jl documentation</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">FIRLS.jl documentation</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>Manual</a><ul class="internal"><li><a class="tocitem" href="#Installation"><span>Installation</span></a></li><li><a class="tocitem" href="#Usage"><span>Usage</span></a></li><li><a class="tocitem" href="#Functions"><span>Functions</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Manual</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Manual</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/ltjkoomen/FIRLS.jl/blob/master/docs/src/manual.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Manual"><a class="docs-heading-anchor" href="#Manual">Manual</a><a id="Manual-1"></a><a class="docs-heading-anchor-permalink" href="#Manual" title="Permalink"></a></h1><h2 id="Installation"><a class="docs-heading-anchor" href="#Installation">Installation</a><a id="Installation-1"></a><a class="docs-heading-anchor-permalink" href="#Installation" title="Permalink"></a></h2><p>To install FIRLS.jl, open up julia and do:</p><pre><code class="language-julia">pkg&gt; update
pkg&gt; add FIRLS</code></pre><h2 id="Usage"><a class="docs-heading-anchor" href="#Usage">Usage</a><a id="Usage-1"></a><a class="docs-heading-anchor-permalink" href="#Usage" title="Permalink"></a></h2><h3 id="Unweighted-least-squares-FIR-design"><a class="docs-heading-anchor" href="#Unweighted-least-squares-FIR-design">Unweighted least-squares FIR design</a><a id="Unweighted-least-squares-FIR-design-1"></a><a class="docs-heading-anchor-permalink" href="#Unweighted-least-squares-FIR-design" title="Permalink"></a></h3><p>Let&#39;s say we want to design a bandpass filter with a passband from <em>1 Hz</em> to <em>2 Hz</em>, with a sampling frequency of <em>6 Hz</em>, a filter order of <em>10</em>, and symmetric filter coefficients. </p><p>We can do this as follows:</p><pre><code class="language-julia-repl">julia&gt; using FIRLS;

julia&gt; fs = 6;

julia&gt; filter_order = 10;

julia&gt; antisymmetric = false;</code></pre><p>Set the frequency-band matrix:</p><pre><code class="language-julia-repl">julia&gt; freq_bands = [0 1; 1 2; 2 3];</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Frequency bands must not overlap and must completely cover the range <span>$[0, f_s/2]$</span>.</p></div></div><p>Define the amplitude response:</p><pre><code class="language-julia-repl">julia&gt; D = [0. 0.; 1. 1.; 0. 0.];</code></pre><p>Now we can design the filter:</p><pre><code class="language-julia">h = firls_design(filter_order, freq_bands, D, antisymmetric; fs = fs)</code></pre><pre class="documenter-example-output">11-element Vector{Float64}:
  7.424814296795033e-17
  0.13783222385544808
 -3.898171832519375e-17
 -0.27566444771089604
  3.222575649650622e-17
  0.3333333333333333
  3.222575649650622e-17
 -0.27566444771089604
 -3.898171832519375e-17
  0.13783222385544808
  7.424814296795033e-17</pre><h3 id="Weighted-least-squares-FIR-design"><a class="docs-heading-anchor" href="#Weighted-least-squares-FIR-design">Weighted least-squares FIR design</a><a id="Weighted-least-squares-FIR-design-1"></a><a class="docs-heading-anchor-permalink" href="#Weighted-least-squares-FIR-design" title="Permalink"></a></h3><p>Now let&#39;s say we want to design the same filter, but this time we want to place more weight on errors in the passband. We can do this by defining the following weighting coefficient matrix:</p><pre><code class="language-julia-repl">julia&gt; W = [1 2; 2 2; 2 1];</code></pre><p>Now we can design the filter with the weight function:</p><pre><code class="language-julia">h = firls_design(filter_order, bands_D, D, W, antisymmetric; fs = fs)</code></pre><pre class="documenter-example-output">11-element Vector{Float64}:
  5.851941012279437e-17
  0.1403757865290026
 -7.540357228407273e-18
 -0.27528418302327057
  2.972899058715575e-17
  0.3342918305637282
  2.972899058715575e-17
 -0.27528418302327057
 -7.540357228407273e-18
  0.1403757865290026
  5.851941012279437e-17</pre><h3 id="Different-input-forms"><a class="docs-heading-anchor" href="#Different-input-forms">Different input forms</a><a id="Different-input-forms-1"></a><a class="docs-heading-anchor-permalink" href="#Different-input-forms" title="Permalink"></a></h3><p>You can use the <code>firls_design</code> function with several different input shapes for the frequency, amplitude response, and weighting function values. They are listed in the table below:</p><table><tr><th style="text-align: right"><strong>Frequency bands</strong></th><th style="text-align: right"><strong>Amplitude response</strong></th><th style="text-align: right"><strong>Weighting function</strong></th><th style="text-align: right"><strong>Comments</strong></th></tr><tr><td style="text-align: right"><code>Matrix</code></td><td style="text-align: right"><code>Union{Vector,Matrix}</code></td><td style="text-align: right"><code>Union{Vector,Matrix}</code></td><td style="text-align: right">Vectors are interpreted as constant values over the frequency band.</td></tr><tr><td style="text-align: right"><code>Vector</code></td><td style="text-align: right"><code>Vector</code></td><td style="text-align: right"><code>Vector</code></td><td style="text-align: right">Vectors are interpreted as frequency knotpoints and values at those knotpoints.</td></tr><tr><td style="text-align: right"><code>Matrix</code></td><td style="text-align: right"><code>Union{Vector,Matrix}</code></td><td style="text-align: right">N/A</td><td style="text-align: right">Vectors are interpreted as constant values over the frequency band.</td></tr><tr><td style="text-align: right"><code>Vector</code></td><td style="text-align: right"><code>Vector</code></td><td style="text-align: right">N/A</td><td style="text-align: right">Vectors are interpreted as frequency knotpoints and values at those knotpoints.</td></tr></table><h2 id="Functions"><a class="docs-heading-anchor" href="#Functions">Functions</a><a id="Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Functions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="FIRLS._to_impulse_response-Tuple{Any, FIRLS.FIR_III}" href="#FIRLS._to_impulse_response-Tuple{Any, FIRLS.FIR_III}"><code>FIRLS._to_impulse_response</code></a> — <span class="docstring-category">Method</span></header><section><div><p>For type III FIR filters:</p><p class="math-container">\[    h = \bigg[ a[M+1] \quad a[M] \quad \cdots \quad a[2] \quad 0 \quad -a[2] \quad \cdots \quad -a[M+1] \bigg]^T\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ltjkoomen/FIRLS.jl/blob/5747879e7b6ccecbd442139c3ee25da30eda0355/src/FIRLS.jl#L632-L637">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FIRLS._to_impulse_response-Tuple{Any, FIRLS.FIR_II}" href="#FIRLS._to_impulse_response-Tuple{Any, FIRLS.FIR_II}"><code>FIRLS._to_impulse_response</code></a> — <span class="docstring-category">Method</span></header><section><div><p>For type II FIR filters:</p><p class="math-container">\[    h = \bigg[ a[M+1] \quad a[M] \quad \cdots \quad a[2] \quad a[1] \quad a[1] \quad a[2] \quad \cdots \quad a[M+1] \bigg]^T\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ltjkoomen/FIRLS.jl/blob/5747879e7b6ccecbd442139c3ee25da30eda0355/src/FIRLS.jl#L619-L624">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FIRLS._to_impulse_response-Tuple{Any, FIRLS.FIR_IV}" href="#FIRLS._to_impulse_response-Tuple{Any, FIRLS.FIR_IV}"><code>FIRLS._to_impulse_response</code></a> — <span class="docstring-category">Method</span></header><section><div><p>For type IV FIR filters:</p><p class="math-container">\[    h = \bigg[ a[M+1] \quad a[M] \quad \cdots \quad a[2] \quad 0 \quad 0 \quad -a[2] \quad \cdots \quad -a[M+1] \bigg]^T\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ltjkoomen/FIRLS.jl/blob/5747879e7b6ccecbd442139c3ee25da30eda0355/src/FIRLS.jl#L645-L650">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FIRLS._to_impulse_response-Tuple{Any, FIRLS.FIR_I}" href="#FIRLS._to_impulse_response-Tuple{Any, FIRLS.FIR_I}"><code>FIRLS._to_impulse_response</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">_to_impulse_response(a, fir_type)</code></pre><p>Creates a linear phase FIR filter based on <code>fir_type</code> and the coefficients in vector <span>$a$</span>, which was obtained by solving the linear equation <span>$Qa = b$</span>.</p><p>...</p><p><strong>Arguments</strong></p><p>-<code>a</code>::Vector      : a vector of size <code>(M+1,)</code> with coefficients.   </p><ul><li><code>fir_type::FIR</code> : indicates the type of FIR filter.</li></ul><p><strong>Outputs</strong></p><p>-<code>h</code>::Vector      : a vector of size (filter_order+1,) with the filter coefficients. ...</p><p>For type I FIR filters:</p><p class="math-container">\[    h = \bigg[ a[M+1] \quad a[M] \quad \cdots \quad a[2] \quad a[1] \quad a[2] \quad \cdots \quad a[M+1] \bigg]^T\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ltjkoomen/FIRLS.jl/blob/5747879e7b6ccecbd442139c3ee25da30eda0355/src/FIRLS.jl#L592-L610">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FIRLS._update_trig_arg_b!-Tuple{Any, Any, Union{FIRLS.FIR_I, FIRLS.FIR_II}}" href="#FIRLS._update_trig_arg_b!-Tuple{Any, Any, Union{FIRLS.FIR_I, FIRLS.FIR_II}}"><code>FIRLS._update_trig_arg_b!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">_update_trig_arg_b!(_αn, n, fir_type::Union{FIR_I,FIR_II})</code></pre><p>Updates the argument of the trigonometric functions in <a href="#FIRLS.bn!-NTuple{7, Any}"><code>bn!</code></a> by multiplying with the current <code>n</code>.</p><p>...</p><p><strong>Arguments</strong></p><ul><li><code>_αn::Vector</code> : a vector of size <code>(J,)</code></li><li><code>n::Real</code></li><li><code>fir_type{Union{FIR_I,FIR_II}}</code></li></ul><p>...</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ltjkoomen/FIRLS.jl/blob/5747879e7b6ccecbd442139c3ee25da30eda0355/src/FIRLS.jl#L561-L572">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FIRLS._update_trig_arg_b!-Tuple{Any, Any, Union{FIRLS.FIR_III, FIRLS.FIR_IV}}" href="#FIRLS._update_trig_arg_b!-Tuple{Any, Any, Union{FIRLS.FIR_III, FIRLS.FIR_IV}}"><code>FIRLS._update_trig_arg_b!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">_update_trig_arg_b!(_αn, n, fir_type::Union{FIR_III,FIR_IV})</code></pre><p>Updates the argument of the trigonometric functions in <a href="#FIRLS.bn!-NTuple{7, Any}"><code>bn!</code></a> by multiplying with <span>$n$</span> and subtracting <span>$\pi$</span>. The subtraction of <span>$\pi$</span> is necessary because when the filter is antisymmetric (type III and IV FIR filters), the filter response is a sum of sines instead of cosines and <span>$\sin(x) = \cos(x - \pi/2)$</span> (see page 12 and 13 of <a href="https://eeweb.engineering.nyu.edu/iselesni/EL713/zoom/linphase.pdf">this</a>).</p><p>...</p><p><strong>Arguments</strong></p><ul><li><code>_αn::Vector</code> : a vector of size <code>(J,)</code></li><li><code>n::Real</code></li><li><code>fir_type::Union{FIR_III,FIR_IV}</code></li></ul><p>...</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ltjkoomen/FIRLS.jl/blob/5747879e7b6ccecbd442139c3ee25da30eda0355/src/FIRLS.jl#L574-L586">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FIRLS.bn!-NTuple{7, Any}" href="#FIRLS.bn!-NTuple{7, Any}"><code>FIRLS.bn!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">bn!(_bn, k, f, a, b, c, d)</code></pre><p>Special case for when <span>$n = 0$</span>, since then the integral is simplified:</p><p class="math-container">\[g_j(f,0) = (c_j f+d_j) (a_j f+b_j) \cos(\pi k f 0) = (c_j f+d_j) (a_j f+b_j)\]</p><p>And the antiderivative becomes:</p><p class="math-container">\[G_j(f,0) = a_j c_j \frac{f^3}{3}  + (a_j d_j + b_j c_j)\frac{f^2}{2} + b_j d_j f\]</p><p>...</p><p><strong>Arguments</strong></p><ul><li><code>_bn::Vector</code> : a vector of size <code>(J,)</code> that is used to store the intermdediate values.</li><li><code>k::Real</code> : equal to <span>$2/f_s$</span>.</li><li><code>f::Matrix</code> : a matrix of size <code>(J,2)</code> which contains rows of sequential frequency bands, spanning [0, fs/2].</li><li><code>a::Vector</code> : a vector of size <code>(J,)</code> with the <span>$a_j$</span> values in the equation <span>$a_j f + b_j$</span> that equates to the linear function that describes the desired frequency response in the <span>$j^{th}$</span> frequency band.</li><li><code>b::Vector</code> : a vector of size <code>(J,)</code> with the <span>$b_j$</span> values in the equation <span>$a_j f + b_j$</span> that equates to the linear function that describes the desired frequency response in the <span>$j^{th}$</span> frequency band.</li><li><code>c::Vector</code> : a vector of size <code>(J,)</code> with the <span>$c_j$</span> values in the equation <span>$c_j f + d_j$</span> that equates to the linear function that describes the error weighting function in the <span>$j^{th}$</span> frequency band.</li><li><code>d::Vector</code> : a vector of size <code>(J,)</code> with the <span>$d_j$</span> values in the equation <span>$c_j f + d_j$</span> that equates to the linear function that describes the error weighting function in the <span>$j^{th}$</span> frequency band.</li></ul><p>...</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ltjkoomen/FIRLS.jl/blob/5747879e7b6ccecbd442139c3ee25da30eda0355/src/FIRLS.jl#L526-L548">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FIRLS.bn!-NTuple{8, Any}" href="#FIRLS.bn!-NTuple{8, Any}"><code>FIRLS.bn!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">bn!(_bn, n, k, _αn, _βn², γ, _δn, fir_type)</code></pre><p>Calculates the elements of the b-vector, which are equal to: </p><p class="math-container">\[b[i] = \frac{2}{f_s} \int_0^{f_s/2} W(f) D(f) cos(\pi \frac{2}{f_s} n f) df, \quad i = 1, 2, \cdots, M+1\]</p><p>Both <span>$D(f)$</span> and <span>$W(f)$</span> are piecewise linear functions, and <span>$n$</span> is calculated by <a href="#FIRLS.idx2n_b-Tuple{Any, Union{FIRLS.FIR_I, FIRLS.FIR_III}}"><code>idx2n_b</code></a>. Using <span>$k = 2/f_s$</span>, this integral becomes:</p><p class="math-container">\[b[i] = k \sum_{j=1}^J \int_{F_{j,1}}^{F_{j,2}} g_j(f,n) df = k \sum_{j=1}^J \int_{F_{j,1}}^{F_{j,2}} \big(c_j f+d_j\big) \big(a_j f+b_j\big) \cos(\pi k n f) df, \quad i = 1, 2, \cdots, M+1\]</p><p>Where:</p><ul><li><span>$F_{j,1}$</span> and <span>$F_{j,2}$</span> are the lower and upper bound of the <span>$j^{th}$</span> frequency band.</li><li><span>$a_j$</span> and <span>$b_j$</span> are the parameters of the linear function that describes the desired frequency response in the <span>$j^{th}$</span> frequency band.</li><li><span>$c_j$</span> and <span>$d_j$</span> are the parameters of the linear function that describes the error weighting function in the <span>$j^{th}$</span> frequency band.</li></ul><p>The antiderivative of <span>$g(f,n)$</span> is equal to:</p><p class="math-container">\[G_j(f,n) = \frac{1}{\pi^3 k^3 n^3} \bigg(\sin\big(\alpha(f) n\big)\Big(\beta_j(f) n^2 + \gamma_j(f)\Big) + \delta_j(f) n \cos\big(\alpha(f) n\big)\bigg) + constants\]</p><p>Where:</p><ul><li><span>$\alpha(f) = \pi kf$</span>, </li><li><span>$\beta(f) = \pi^2 k^2 \big(acf^2 + (ad+bc)f + bd\big)$</span>, </li><li><span>$\gamma(f) = -2ac$</span>, </li><li><span>$\delta(f) = \pi k\big(2acf + ad + bc\big)$</span>.</li></ul><p>Note that the subscripts have been dropped here for clarity.</p><p>...</p><p><strong>Arguments</strong></p><ul><li><code>_bn::Vector</code>   : a vector of size <code>(J,)</code> that is used to store the intermediate values.</li><li><code>n::Integer</code>    : integer denoting the current cosine mode.</li><li><code>k::Real</code>       : equal to <code>2/fs</code>.</li><li><code>_αn::Vector</code>   : a vector of size <code>(J,)</code> that holds the values of <span>$\alpha n$</span>.</li><li><code>_βn²::Vector</code>  : a vector of size <code>(J,)</code> that holds the values of <span>$\beta n^2$</span>.</li><li><code>γ::Vector</code>     : a vector of size <code>(J,)</code> that holds the values of <span>$\gamma$</span>.</li><li><code>_δn::Vector</code>   : a vector of size <code>(J,)</code> that holds the values of <span>$\delta n$</span>.</li><li><code>fir_type::FIR</code> : indicates the type of FIR filter.</li></ul><p><strong>Outputs</strong></p><ul><li><code>bn</code>            : <span>$n^{th}$</span> element in the <span>$b$</span> vector.</li></ul><p>...</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ltjkoomen/FIRLS.jl/blob/5747879e7b6ccecbd442139c3ee25da30eda0355/src/FIRLS.jl#L469-L511">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FIRLS.bn_n0!-NTuple{13, Any}" href="#FIRLS.bn_n0!-NTuple{13, Any}"><code>FIRLS.bn_n0!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">bn_n0!(_bn, n, k, f, a, b, c, d, _αn, _βn², γ, _δn, fir_type)</code></pre><p>Dispatches to the correct function to calculate the first element of the <code>b</code> vector, based on the type of FIR filter. Needed because for type I FIR filters the value of <code>n</code> at the first iteration is <code>0</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ltjkoomen/FIRLS.jl/blob/5747879e7b6ccecbd442139c3ee25da30eda0355/src/FIRLS.jl#L422-L427">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FIRLS.constants_b-Tuple{Any, Any, Any}" href="#FIRLS.constants_b-Tuple{Any, Any, Any}"><code>FIRLS.constants_b</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">constants_b(f, D, W)</code></pre><p>Calculates data that is reused at every evaluation of <a href="#FIRLS.bn!-NTuple{7, Any}"><code>bn!</code></a>.</p><p>...</p><p><strong>Arguments</strong></p><ul><li><code>f::Matrix</code> : a matrix of size <code>(N,2)</code> which contains rows of sequential frequency bands, spanning the interval [0, fs/2].</li><li><code>D::Matrix</code> : a matrix of size <code>(N,2)</code> which contains rows of desired frequency response values for the frequency bands in <code>f</code>. The first and second columns indicate the desired response at the lower and upper bound of the frequency bands, interpolated linearly in between.</li><li><code>W::Matrix</code> : a matrix of size <code>(N,2)</code> which contains rows of weighting coefficients for the frequency bands in <code>f</code>. The first and second columns indicate the weighting at the lower and upper bound of the frequency bands, interpolated linearly in between.</li></ul><p>...</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ltjkoomen/FIRLS.jl/blob/5747879e7b6ccecbd442139c3ee25da30eda0355/src/FIRLS.jl#L397-L408">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FIRLS.firls_design-Tuple{Integer, Matrix{T} where T, Matrix{T} where T, Matrix{T} where T, Bool}" href="#FIRLS.firls_design-Tuple{Integer, Matrix{T} where T, Matrix{T} where T, Matrix{T} where T, Bool}"><code>FIRLS.firls_design</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">firls_design(filter_order::Integer, bands_DW::Matrix, D::Matrix, W::Matrix, antisymmetric::Bool; fs::Real = 1, solver::Function = \)</code></pre><p>Designs a linear-phase FIR filter.</p><p><strong>Arguments</strong></p><ul><li><code>filter_order::Integer</code>   : the order of the FIR filter.</li><li><code>bands_DW::Matrix</code>        : a matrix of size (N,2) which contains rows of sequential frequency bands, spanning [0, fs/2].</li><li><code>D::Matrix</code>               : a matrix of size (N,2) which contains rows of amplitude responses for the frequency bands in <code>bands_DW</code>. The first and second columns indicate the amplitude response at the lower and upper bound of the frequency bands, interpolated linearly in between.</li><li><code>W::Matrix</code>               : a matrix of size (N,2) which contains rows of weighting coefficients for the frequency bands in <code>bands_DW</code>. The first and second columns indicate the weighting at the lower and upper bound of the frequency bands, interpolated linearly in between.</li><li><code>antisymmetric::Bool</code>     : a Boolean that signifies whether the filter coefficients will be anti-symmetric, as used in type III and IV FIR filters.</li><li><code>fs::Real</code>                : the sampling frequency.</li><li><code>solver::Function</code>        : the function that is called to solve the equation <span>$Qa = b$</span>, with the function call: <code>solver(Q,b)</code> which returns <code>a</code>.</li></ul><p><strong>Outputs</strong></p><ul><li><code>h</code> : a vector of linear-phase FIR filter coefficients.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ltjkoomen/FIRLS.jl/blob/5747879e7b6ccecbd442139c3ee25da30eda0355/src/FIRLS.jl#L109-L125">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FIRLS.firls_design-Tuple{Integer, Matrix{T} where T, VecOrMat{T} where T, Bool}" href="#FIRLS.firls_design-Tuple{Integer, Matrix{T} where T, VecOrMat{T} where T, Bool}"><code>FIRLS.firls_design</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">firls_design(filter_order::Integer, bands_DW::Matrix, D::Union{Vector,Matrix}, antisymmetric::Bool; fs::Real = 1, solver::Function = \)</code></pre><p><strong>Arguments</strong></p><ul><li><code>filter_order::Integer</code>   : the order of the FIR filter.</li><li><code>bands_DW::Matrix</code>        : a matrix of size <code>(N,2)</code> which contains rows of sequential frequency bands, spanning [0, fs/2].</li><li><code>D::Union{Vector,Matrix}</code> : a matrix of size <code>(N,2)</code>, or a vector of size <code>(N,)</code>, which amplitude responses for the frequency bands in <code>bands_DW</code>. In the case of a matrix, the first and second columns indicate the amplitude response at the lower and upper bound of the frequency bands, interpolated linearly in between. In the case of a vector the elements the amplitude response is piecewise constant.</li><li><code>antisymmetric::Bool</code>     : a Boolean that signifies whether the filter coefficients will be anti-symmetric, as used in type III and IV FIR filters.</li><li><code>fs::Real</code>                : the sampling frequency.</li><li><code>solver::Function</code>        : the function that is called to solve the equation <span>$Qa = b$</span>, with the function call: <code>solver(Q,b)</code> which returns <code>a</code>.</li></ul><p><strong>Outputs</strong></p><ul><li><code>h</code> : a vector of linear-phase FIR filter coefficients.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ltjkoomen/FIRLS.jl/blob/5747879e7b6ccecbd442139c3ee25da30eda0355/src/FIRLS.jl#L171-L184">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FIRLS.firls_design-Tuple{Integer, Matrix{T} where T, VecOrMat{T} where T, VecOrMat{T} where T, Bool}" href="#FIRLS.firls_design-Tuple{Integer, Matrix{T} where T, VecOrMat{T} where T, VecOrMat{T} where T, Bool}"><code>FIRLS.firls_design</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">firls_design(filter_order::Integer, bands_DW::Matrix, D::Union{Vector,Matrix}, W::Union{Vector,Matrix}, antisymmetric::Bool; fs::Real = 1, solver::Function = \)</code></pre><p><strong>Arguments</strong></p><ul><li><code>filter_order::Integer</code>   : the order of the FIR filter.</li><li><code>bands_DW::Matrix</code>        : a matrix of size <code>(N,2)</code> which contains rows of sequential frequency bands, spanning [0, fs/2].</li><li><code>D::Union{Vector,Matrix}</code> : a matrix of size <code>(N,2)</code>, or a vector of size <code>(N,)</code>, which amplitude responses for the frequency bands in <code>bands_DW</code>. In the case of a matrix, the first and second columns indicate the amplitude response at the lower and upper bound of the frequency bands, interpolated linearly in between. In the case of a vector the elements the amplitude response is piecewise constant.</li><li><code>W::Union{Vector,Matrix}</code> : a matrix of size <code>(N,2)</code>, or a vector of size <code>(N,)</code>, which contains weighting function values for the frequency bands in <code>bands_DW</code>. In the case of a matrix, the first and second columns indicate the weighting function values at the lower and upper bound of the frequency bands, interpolated linearly in between. In the case of a vector the elements the weighting function is piecewise constant.</li><li><code>antisymmetric::Bool</code>     : a Boolean that signifies whether the filter coefficients will be anti-symmetric, as used in type III and IV FIR filters.</li><li><code>fs::Real</code>                : the sampling frequency.</li><li><code>solver::Function</code>        : the function that is called to solve the equation <span>$Qa = b$</span>, with the function call: <code>solver(Q,b)</code> which returns <code>a</code>.</li></ul><p><strong>Outputs</strong></p><ul><li><code>h</code> : a vector of linear-phase FIR filter coefficients.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ltjkoomen/FIRLS.jl/blob/5747879e7b6ccecbd442139c3ee25da30eda0355/src/FIRLS.jl#L133-L147">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FIRLS.firls_design-Tuple{Integer, Vector{T} where T, Vector{T} where T, Bool}" href="#FIRLS.firls_design-Tuple{Integer, Vector{T} where T, Vector{T} where T, Bool}"><code>FIRLS.firls_design</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">firls_design(filter_order::Integer, knotpoints_D::Vector, D::Vector, antisymmetric::Bool; fs::Real = 1, solver::Function = \)</code></pre><p><strong>Arguments</strong></p><ul><li><code>filter_order::Integer</code>   : the order of the FIR filter.</li><li><code>knotpoints_D::Vector</code>    : a vector of size <code>(N,)</code> which contains frequency knotpoints, spanning [0, fs/2].</li><li><code>D::Vector</code>               : a vector of size <code>(N,)</code> which contains amplitude response values for the frequency knotpoints in <code>knotpoints_D::Vector</code>.</li><li><code>antisymmetric::Bool</code>     : a Boolean that signifies whether the filter coefficients will be anti-symmetric, as used in type III and IV FIR filters.</li><li><code>fs::Real</code>                : the sampling frequency.</li><li><code>solver::Function</code>        : the function that is called to solve the equation <span>$Qa = b$</span>, with the function call: <code>solver(Q,b)</code> which returns <code>a</code>.</li></ul><p><strong>Outputs</strong></p><ul><li><code>h</code> : a vector of linear-phase FIR filter coefficients.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ltjkoomen/FIRLS.jl/blob/5747879e7b6ccecbd442139c3ee25da30eda0355/src/FIRLS.jl#L194-L207">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FIRLS.firls_design-Tuple{Integer, Vector{T} where T, Vector{T} where T, Vector{T} where T, Bool}" href="#FIRLS.firls_design-Tuple{Integer, Vector{T} where T, Vector{T} where T, Vector{T} where T, Bool}"><code>FIRLS.firls_design</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">firls_design(filter_order::Integer, knotpoints_DW::Vector, D::Vector, W::Vector, antisymmetric::Bool; fs::Real = 1, solver::Function = \)</code></pre><p><strong>Arguments</strong></p><ul><li><code>filter_order::Integer</code>   : the order of the FIR filter.</li><li><code>knotpoints_DW::Vector</code>   : a vector of size <code>(N,)</code> which contains frequency knotpoints, spanning [0, fs/2].</li><li><code>D::Vector</code>               : a vector of size <code>(N,)</code> which contains amplitude response values for the frequency knotpoints in <code>knotpoints_DW</code>. </li><li><code>W::Vector</code>               : a vector of size <code>(N,)</code> which contains weighting function values for the frequency knotpoints in <code>knotpoints_DW</code>. </li><li><code>antisymmetric::Bool</code>     : a Boolean that signifies whether the filter coefficients will be anti-symmetric, as used in type III and IV FIR filters.</li><li><code>fs::Real</code>                : the sampling frequency.</li><li><code>solver::Function</code>        : the function that is called to solve the equation <span>$Qa = b$</span>, with the function call: <code>solver(Q,b)</code> which returns <code>a</code>.</li></ul><p><strong>Outputs</strong></p><ul><li><code>h</code> : a vector of linear-phase FIR filter coefficients.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ltjkoomen/FIRLS.jl/blob/5747879e7b6ccecbd442139c3ee25da30eda0355/src/FIRLS.jl#L152-L166">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FIRLS.get_Q-NTuple{4, Any}" href="#FIRLS.get_Q-NTuple{4, Any}"><code>FIRLS.get_Q</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_Q(M, f, W, fir_type)</code></pre><p>Constructs the matrix <span>$Q$</span> used in the equation <span>$Qa = b$</span>, based on a set of weights.</p><p><strong>Arguments</strong></p><ul><li><code>M::Integer</code>      : indicator of the amount of elements needed.</li><li><code>f::Matrix</code>       : a matrix of size <code>(N,2)</code> which contains rows of sequential frequency bands, spanning [0, fs/2].</li><li><code>W::Matrix</code>       : a matrix of size <code>(N,2)</code> which contains rows of weighting coefficients for the frequency bands in <code>f</code>. The first and second columns indicate the weighting at the lower and upper bound of the frequency bands, interpolated linearly in between.</li><li><code>fir_type::FIR</code>   : indicates the type of FIR filter.</li></ul><p><strong>Outputs</strong></p><ul><li><code>Q::Matrix</code> : the matrix <span>$Q$</span> used in the equation <span>$Qa = b$</span>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ltjkoomen/FIRLS.jl/blob/5747879e7b6ccecbd442139c3ee25da30eda0355/src/FIRLS.jl#L239-L252">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FIRLS.get_Q-Tuple{Any, Any}" href="#FIRLS.get_Q-Tuple{Any, Any}"><code>FIRLS.get_Q</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_Q(M, fir_type)</code></pre><p>Constructs the matrix <span>$Q$</span> used in the equation <span>$Qa = b$</span>, when there are no weights. Which results in <span>$Q$</span> being the identity matrix.</p><p><strong>Arguments</strong></p><ul><li><code>M::Integer</code>      : indicator of the amount of elements needed.</li><li><code>fir_type::FIR</code>   : indicates the type of FIR filter.</li></ul><p><strong>Outputs</strong></p><ul><li><code>Q::Matrix</code> : the matrix <span>$Q$</span> used in the equation <span>$Qa = b$</span>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ltjkoomen/FIRLS.jl/blob/5747879e7b6ccecbd442139c3ee25da30eda0355/src/FIRLS.jl#L258-L269">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FIRLS.get_Q-Tuple{Any, FIRLS.FIR_I}" href="#FIRLS.get_Q-Tuple{Any, FIRLS.FIR_I}"><code>FIRLS.get_Q</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_Q(M, fir_type::FIR_I)</code></pre><p>Constructs the matrix <span>$Q$</span> used in the equation <span>$Qa = b$</span>, when there are no weights and the FIR filter is of type I.</p><p><strong>Arguments</strong></p><ul><li><code>M::Integer</code>      : indicator of the amount of elements needed.</li><li><code>fir_type::FIR_I</code>   : indicates the type of FIR filter is I.</li></ul><p><strong>Outputs</strong></p><ul><li><code>Q::Matrix</code> : the matrix <span>$Q$</span> used in the equation <span>$Qa = b$</span>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ltjkoomen/FIRLS.jl/blob/5747879e7b6ccecbd442139c3ee25da30eda0355/src/FIRLS.jl#L271-L282">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FIRLS.get_b-NTuple{5, Any}" href="#FIRLS.get_b-NTuple{5, Any}"><code>FIRLS.get_b</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_b(M, f, D, W, fir_type)</code></pre><p>Finds the vector <span>$b$</span> used in the equation <span>$Qa = b$</span>. ...</p><p><strong>Arguments</strong></p><ul><li><code>M::Integer</code>      : Size of the <code>b</code> vector is <code>M+1</code> .</li><li><code>f::Matrix</code>       : a matrix of size <code>(N,2)</code> which contains rows of sequential frequency bands, spanning the interval [0, fs/2].</li><li><code>D::Matrix</code>       : a matrix of size <code>(N,2)</code> which contains rows of desired frequency response values for the frequency bands in <code>f</code>. The first and second columns indicate the desired response at the lower and upper bound of the frequency bands, interpolated linearly in between.</li><li><code>W::Matrix</code>       : a matrix of size <code>(N,2)</code> which contains rows of weighting coefficients for the frequency bands in <code>f</code>. The first and second columns indicate the weighting at the lower and upper bound of the frequency bands, interpolated linearly in between.</li><li><code>fir_type::FIR</code>   : indicates the type of FIR filter.</li></ul><p><strong>Outputs</strong></p><ul><li><code>b_out::Vector</code>   : a vector of size <code>(M+1,)</code>, the b-vector used in the equation <span>$Qa = b$</span>.</li></ul><p>...</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ltjkoomen/FIRLS.jl/blob/5747879e7b6ccecbd442139c3ee25da30eda0355/src/FIRLS.jl#L368-L383">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FIRLS.get_flength_M-Tuple{Any}" href="#FIRLS.get_flength_M-Tuple{Any}"><code>FIRLS.get_flength_M</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_flength_M(filter_order)</code></pre><p>Determines the length of the FIR filter and the number of amplitude coefficients needed, based on its order.</p><p><strong>Arguments</strong></p><ul><li><code>filter_order::Integer</code> : the order of the FIR filter.</li></ul><p><strong>Outputs</strong></p><ul><li><code>filter_length::Integer</code> : the number of filter coefficients</li><li><code>M::Integer</code> : the number of unique amplitude coefficients needed to form the filter is equal to <span>$M+1$</span></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ltjkoomen/FIRLS.jl/blob/5747879e7b6ccecbd442139c3ee25da30eda0355/src/FIRLS.jl#L86-L97">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FIRLS.get_q-NTuple{4, Any}" href="#FIRLS.get_q-NTuple{4, Any}"><code>FIRLS.get_q</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_q(M, f, W, fir_type)</code></pre><p>Finds the vector <span>$q$</span> which is used to populate the matrix <span>$Q$</span>. ...</p><p><strong>Arguments</strong></p><ul><li><code>M::Integer</code>      : indicator of the amount of elements needed.</li><li><code>f::Matrix</code>       : a matrix of size <code>(N,2)</code> which contains rows of sequential frequency bands, spanning [0, fs/2].</li><li><code>W::Matrix</code>       : a matrix of size <code>(N,2)</code> which contains rows of weighting coefficients for the frequency bands in <code>f</code>. The first and second columns indicate the weighting at the lower and upper bound of the frequency bands, interpolated linearly in between.</li><li><code>fir_type::FIR</code>   : indicates the type of FIR filter.</li></ul><p><strong>Outputs</strong></p><ul><li><code>q_out::Vector</code>   : a vector of q-values that are used to fill in the Q-matrix.</li></ul><p>...</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ltjkoomen/FIRLS.jl/blob/5747879e7b6ccecbd442139c3ee25da30eda0355/src/FIRLS.jl#L303-L317">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FIRLS.idx2n_b-Tuple{Any, Union{FIRLS.FIR_I, FIRLS.FIR_III}}" href="#FIRLS.idx2n_b-Tuple{Any, Union{FIRLS.FIR_I, FIRLS.FIR_III}}"><code>FIRLS.idx2n_b</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">idx2n_b(idx, fir_type::Union{FIR_I,FIR_III})</code></pre><p>Determine the value of <span>$n$</span> based on the index in the b-vector. For type I and III FIR filters the following holds: <span>$n = i - 1$</span>. Based on page 10 and 12 of <a href="https://eeweb.engineering.nyu.edu/iselesni/EL713/zoom/linphase.pdf">this</a>.</p><p>...</p><p><strong>Arguments</strong></p><ul><li><code>i::Integer</code> : index in the b-vector.</li><li><code>fir_type::Union{FIR_I,FIR_III}</code></li></ul><p><strong>Outputs</strong></p><ul><li><code>n::Real</code></li></ul><p>...</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ltjkoomen/FIRLS.jl/blob/5747879e7b6ccecbd442139c3ee25da30eda0355/src/FIRLS.jl#L435-L449">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FIRLS.idx2n_b-Tuple{Any, Union{FIRLS.FIR_II, FIRLS.FIR_IV}}" href="#FIRLS.idx2n_b-Tuple{Any, Union{FIRLS.FIR_II, FIRLS.FIR_IV}}"><code>FIRLS.idx2n_b</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">idx2n_b(idx, fir_type::Union{FIR_II,FIR_IV})</code></pre><p>Determine the value of <span>$n$</span> based on the index in the b-vector, Where <span>$n$</span> is used in  For type II and IV FIR filters the following holds: <span>$n = i - 1/2$</span>. Based on page 11 and 13 of <a href="https://eeweb.engineering.nyu.edu/iselesni/EL713/zoom/linphase.pdf">this</a>.</p><p>...</p><p><strong>Arguments</strong></p><ul><li><code>i::Integer</code> : index in the b-vector.</li><li><code>fir_type::Union{FIR_II,FIR_IV}</code></li></ul><p><strong>Outputs</strong></p><ul><li><code>n::Real</code></li></ul><p>...</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ltjkoomen/FIRLS.jl/blob/5747879e7b6ccecbd442139c3ee25da30eda0355/src/FIRLS.jl#L451-L466">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FIRLS.infer_fir_type-Tuple{Any, Any}" href="#FIRLS.infer_fir_type-Tuple{Any, Any}"><code>FIRLS.infer_fir_type</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">infer_fir_type(is_odd, is_antisymmetric)</code></pre><p>Determines the type of FIR filter to be designed, based on:</p><ul><li>Whether the number of filter coefficients is odd (<code>is_odd</code>)</li><li>Whether the filter should be antisymmetric (<code>is_antisymmetric</code>)</li></ul><p>The result is a <code>fir_type</code>, which can be:</p><ol><li><code>FIR_I</code>, when filter length is odd and the filter is not antisymmetric</li><li><code>FIR_II</code>, when filter length is even and the filter is not antisymmetric</li><li><code>FIR_III</code>, when filter length is odd and the filter is antisymmetric</li><li><code>FIR_IV</code>, when filter length is even and the filter is antisymmetric</li></ol><p><strong>Arguments</strong></p><ul><li><code>is_odd::Bool</code></li><li><code>is_antisymmetric::Bool</code></li></ul><p><strong>Outputs</strong></p><ul><li><code>fir_type::FIR</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ltjkoomen/FIRLS.jl/blob/5747879e7b6ccecbd442139c3ee25da30eda0355/src/FIRLS.jl#L21-L40">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Friday 16 April 2021 18:40">Friday 16 April 2021</span>. Using Julia version 1.6.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
